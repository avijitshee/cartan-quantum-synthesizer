# -*- coding: utf-8 -*-
__docformat__ = 'google'
"""

"""

from util.PauliOps import commutatePauliString

class Cartan:
    """
    Class to contain the options for performing Cartan Decomposition on a Hamiltonian
        
    # Object containing the functions and data required to generate a Cartan Decomposition from a given Hamiltonian. 
    from object_based.PauliOps import commutatePauliString

    TODO:
    * Add in k simplification functions

    Authors:
    * Thomas Steckmann
    * Efekan Kokcu

    Functionality:
    * Generate Hamiltonian Algebra
    * Generate k, m, h partition
    * Choose involution (Default - Even/Odd)
    * Seed choice of h
    * Modify k (Additional Decomposition, TODO: Abelian Decomposition, Piling)
    """
    def __init__(self, hamObj, involution='evenOdd'):
        """ Generates the Cartan Object
        
        Args:
            hamObj (Hamiltonian): Passes a Hamiltonian Object containing the full information about the system
            involution (String, default='evenOdd'):
                Allows a choice of the k,m involuiton

                Options:
                * `'evenOdd'`: m contains an even number of non-identity pauli terms in each string, k contains an odd nunber of non-idenity elements
                * `'knejaGlaser'`: m contains elements ending in Y or X, k contains elements ending in I or Z
                * `'count' + 'X', 'Y', or 'Z'`: Counts of the number of the specified Pauli Tuple. Even count in m, odd in k
        
        Attributes:
            hamiltonian (::hamiltonian:: object): Allows access to HCoefficients and HTuples
            HTuples (List of Tuples): Copies over the HTuples from the hamiltonian object
            g (List of Tuples): Generates formatted like k + h + (m without h)
            k (List of Tuples): Specified by the decomposition. Changing k regenerates h and the order of g (g = k + h + (m\h))
            h (List of Tuples): Specified by SubAlgebra(). Defaults to seeding by m, otherwise allows for inclusion of specific elements
        """
        self.hamiltonian = hamObj
        self.HTuples = self.hamiltonian.HTuples
        self.g = self.makeGroup(self.HTuples)
        self.decompose(involution)
        

    def decompose(self, involutionName):
        """
        Sets a new Involution using a switch. Regenerates h using the default first element in m
        """
        self.involution = involutionName #Store involution name

        if involutionName == 'evenOdd': 
            (self.m, self.k) = self.evenOdd(self.g)
        elif involutionName == 'knejaGlaser':
            (self.m, self.k) = self.knejaGlaser(self.g)
        elif involutionName == 'countX':
            (self.m, self.k) = self.elemcount(self.g, 1)
        elif involutionName == 'countY':
            (self.m, self.k) = self.elemcount(self.g, 2)
        elif involutionName == 'countZ': (self.m, self.k) = self.elemcount(self.g)

        self.subAlgebra()




    def makeGroup(self,g):
        '''
        Returns a closure of a given list of pauli strings (g). The list doesn't include any coefficients, it is just
        a tuple like (0,2,3) representing IYZ.

        Args:
            g (List of Tuples):
                A set of Pauli Strings

        Returns:
            List of Tuples: 𝖌(H), the Hamiltonian Algebra generated by the input g
        '''

        flag = 0
        while (flag == 0):
            flag = 1
            L = len(g)
            #initialize commutations
            coms = []

            #calculate all possible commutations 
            for i in range(L):
                for j in range(i,L):
                    m = commutatePauliString(1,g[i],1,g[j])
                    
                    
                    #add all new ones to the list
                    if (abs(m[0])>0) & (self.included(coms,m[1])==0) & (self.included(g,m[1])==0):
                        #set flag to 0 whenever there is a new term to be added
                        flag = 0
                        coms.append(m[1])

            #then merge initial list with these new commutations
            g = g + coms
        return g
    
    def elemcount(self,g,element):
        '''
        Counts the number of given elements (X,Y or Z in number), and puts even numbers in m, odd numbers in k. 
        For element=2, it corresponds to θ(g) = -g^T
        '''    
        k = []
        m = []
        
        for i in range(len(g)):
            elem = g[i]
            count = 0
            for j in range(len(elem)):
                if elem[j] == element:
                    count=count+1
            if count%2 == 0:
                m.append(elem)
            else:
                k.append(elem)
            
        return m,k
    
    def included(self,g,m):
        '''Following function returns 0 if tuple m is not incu=luded in tuple list g, returns 1 if it is included.
            
            Args:
                g (List of Tuples): 
                    The List of Pauli string elements in the Hamiltonian Algebra 𝖌(H)
                m (Tuple of 0,1,2,3):
                    Pauli string in the set 𝖒

            Returns: 
                1 if m is in g
                0 if not
        '''
        L = len(g)
        res = 0    
        for i in range(L):
            if g[i]==m:
                res = 1
                break
        
        return res


    def evenOdd(self,g):
        """ Partitions the Algebra by counting the number of non-idenity Pauli elements

        Args:
            g (List of Tuples):
                The Algebra to partition
        
        Returns:
            k (List of Tuples):
                The List of Pauli Strings with Odd non-identity terms
            m (List of Tuples):
                The List of Pauli Strings with Even non-idenity terms
        """
        k = []
        m = []
        
        for i in range(len(g)):
            elem = g[i]
            count = 0
            for j in range(len(elem)):
                if elem[j] > 0:
                    count=count+1
            if count%2 == 0:
                m.append(elem)
            else:
                k.append(elem)
                
        return m,k

    def knejaGlaser(self,g):
        '''
        Following one is the Kneja Glaser decomposition. 
        It corresponds to \theta(g) = III...IZ g III..IZ
        ''' 
        k = []
        m = []
        
        for i in range(len(g)):
            elem = g[i]
            last = elem[len(elem)-1]
            if  (last == 3) | (last == 0):
                k.append(elem)
            else:
                m.append(elem)
            
        return m,k

    def subAlgebra(self,seedList=None):
        """ Generates h from a list of Commuting elements in the seedList 
        
        Args:
            seedList (List of Tuples): List of (PauliStrings). Must be commuting
        
        TODO:
            Verify that seedList is commuting
        """
        if seedList == None:
            seedList = [self.m[0]]
        h = seedList.copy()
        for i in range(len(self.m)):
            flag = 0
            for j in range(len(h)):
                if self.m[i] == h[j]:
                    flag = 1
                    break
                    
                comm = commutatePauliString(1, h[j], 1, self.m[i])
                if comm[0] != 0:
                    flag = 1
                    break
            if flag == 0:
                h.append(self.m[i]) 
                
        self.h = h
        #Regenerates the ordering for g, required to generate commutators

        m_tuples = self.m
        #Strips h from m
        index = 0
        while index < len(m_tuples): #
            flag = 0 #When flag = 1, 
            for i in range(len(self.h)):
                if m_tuples[index] == self.h[i]:
                    flag = 1
                    m_tuples.pop(index)
                    break
            if flag == 0:
                index = index + 1
        self.g = self.k + self.h + self.m #Reorder g